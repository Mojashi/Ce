Bool and(Bool a, Bool b){
    Bool ret;
    [-a,-b,ret];
    [a,-ret];
    [b,-ret];
    return ret;
}
Bool or(Bool a, Bool b){
    Bool ret;
    [a,b,-ret];
    [-a,ret];
    [-b,ret];
    return ret;
}
Bool xor(Bool a, Bool b){
    Bool ret;
    [a,b,-ret];
    [-a,-b,-ret];
    [-a,b,ret];
    [a,-b,ret];
    return ret;
}

struct SC{
    Bool s, c;
}
    SC halfadder(Bool a, Bool b){
        SC ret;
        ret.s := xor(a,b);
        ret.c := and(a,b);
        return ret;
    }

    SC fulladder(Bool a, Bool b, Bool c){
        SC ret;
        [-a,-b,-c,ret.s];
        [-a,b,c,ret.s];
        [a,b,-c,ret.s];
        [a,-b,c,ret.s];
        [a,b,c, -ret.s];
        [-a,-b,c,-ret.s];
        [-a,b,-c,-ret.s];
        [a,-b,-c,-ret.s];
        
        [-b,-c,ret.c];
        [-a,-c,ret.c];
        [-b,-a,ret.c];
        [b,c,-ret.c];
        [a,c,-ret.c];
        [b,a,-ret.c];
        return ret;
    }

struct Integer{
    Bool val[8];
    Bool overflow;
    
    Integer operator+(Integer a, Integer b){
        Bool carry;
        Integer ret;
        [-carry];
        for(i,8){
            SC sc;
            sc := fulladder(a.val[i],b.val[i],carry);
            carry := sc.c;
            ret.val[i] := sc.s;
        }
        ret.overflow := or(or(carry,a.overflow),b.overflow);
        return ret;
    }
    Integer operator+(Integer a, Bool b){
        Bool carry;
        Integer ret;
        carry := b;
        for(i,8){
            SC sc;
            sc := halfadder(a.val[i],carry);
            carry := sc.c;
            ret.val[i] := sc.s;
        }
        ret.overflow := or(carry,a.overflow);
        return ret;
    }
    Bool operator==(Integer a, Integer b){
        Bool ret;
        [-ret];
        for(i,8){
            ret := or(ret,xor(a.val[i],b.val[i]));
        }
        ret := or(ret,xor(a.overflow,b.overflow));
        return -ret;
    }
    
    void getInteger(SysInt n){
        for(i,8){
            val[i] := getBit(n,i);
        }
        [-overflow];
    }
}

Integer toInteger(SysInt n){
    Integer ret;
    for(i,8){
        ret.val[i] := getBit(n,i);
    }
    [-ret.overflow];
    return ret;
}

struct Graph{ //単純無向グラフ　自己閉路なし
    Bool matrix[10][10];
    
    void constructor(){
        for(i,10){
            for(j,10){
                matrix[i][j] := matrix[j][i];
            }
            [-matrix[i][i]];
        }
    }

    void addEdge(SysInt from, SysInt to){
        [matrix[from][to]];
        [matrix[to][from]];
    }

    Integer countEdge(){
        Integer num;
        num.getInteger(0);
        for(i,10){
            for(j,i){
                num := num + matrix[i][j];
            }
        }
        return num;
    }

    Graph getMatching(){
        Graph ret;
        ret.constructor();
        
        for(i,10){
            for(j,10){
                [-ret.matrix[i][j],matrix[i][j]]; //マッチングで辺があるのに元のグラフで辺がないのはおかしい。
                for(k,j){
                    [-ret.matrix[i][j], -ret.matrix[i][k]]; //同じ頂点からは1本だけ
                }
            }
        }
        return ret;
    }

    Integer getVertexCoverSize(){
        Bool ar[10];
        Integer count;
        count.getInteger(0);
        for(i, 10){
            for(j,i){
                [-matrix[i][j], ar[i],ar[j]];
            }
        }
        for(i,10){
            count := count + ar[i];
        }
        return count;
    }
}

Graph g,m;
Integer MaxMatchingSize;

void main(){
    g.constructor();
    g.countEdge() = toInteger(20);
    MaxMatchingSize := toInteger(4);

    m := g.getMatching();
    m.countEdge() = MaxMatchingSize;
    g.getVertexCoverSize() = MaxMatchingSize;
}
