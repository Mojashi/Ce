

全体を覆うStructureがあり、メンバ関数とメンバ変数、メンバ構造体を含み、再帰的構造
構造がループ（子孫Structure内で親Structureを型に持つメンバ変数など、参照関係に閉路が存在）するのを禁止、必ずDAGになるように。
→深さが自分と同じか低い構造体への参照のみ？トップレベルにあるInteger構造体などにアクセスできないのでダメ
・アクセスできる構造体は自分と同じか高い構造体（低いのは↓の理由でダメ）で、閉路が出来てるか随時確認する
ある構造体のメンバ関数で親の構造体のメンバ変数にアクセスすると、外部にその構造体が出たときにアクセス先が存在しなくて壊れる
→構造体Aのなかで構造体Bが宣言されている時、Aの子孫の中でしか構造体Bは使えない。Aのメンバ関数でBを返すときにAの親から呼ばれてると壊れそうなので禁止

関数（全ての関数はメンバ関数）から直接（修飾なしで）アクセス出来るのはそれをメンバとする構造体と、
その子孫構造体のメンバ変数とメンバ関数。（スコープ）

プリミティブな構造体はBool,SystemInt,SystemFloat,SystemString

Integer、String、Floatなどの基本的な型は存在することを前提として、（けど、実装は組み込まないでユーザーレベルでやる（やりたいけど遅くなりそうだしどうしよ））
リテラルはSystem~型として解釈、変換はIntegerのメンバ関数としてインタプリタに組み込む。
SystemIntはループカウンタ、配列へのアクセスでも使う。

構造体周りの処理
・構造体ツリーの作成
・構造体指定が具体的にどの構造体を指しているのかを判断して構造体のポインタに置き換え
はAST作るときに一緒にやっちゃう。上述した閉路検出もこの時。

演算子はASTでは全部関数呼び出しと同一視する。

godStruct.main()を最初に呼び出す