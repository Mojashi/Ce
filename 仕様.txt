全体を覆うStructureがあり、メンバ関数とメンバ変数、メンバ構造体を含み、再帰的構造
構造がループ（子孫Structure内で親Structureを型に持つメンバ変数など、参照関係に閉路が存在）するのを禁止、必ずDAGになるように。
→深さが自分と同じか低い構造体への参照のみ？トップレベルにあるInteger構造体などにアクセスできないのでダメ
・メンバ変数の！！！！型として利用できる構造体は自分と同じか高い構造体（低いのは↓の理由でダメ）かつ、先祖のうち一つを兄弟として持つ構造体、閉路が出来てるか随時確認する
→つまるところスコープ内の構造体じゃん、閉路が出来得るのは直接の兄弟の間だけ
・関数内のローカル変数として使えるのはスコープないだったら何でもいいはず。閉路ができて困るのはインスタンス生成時に無限ループができるから。
ある構造体のメンバ関数で親の構造体のメンバ変数にアクセスすると、外部にその構造体が出たときにアクセス先が存在しなくて壊れる
→構造体Aのなかで構造体Bが宣言されている時、Aの子孫の中でしか構造体Bは型として使えない。
Aのメンバ関数でBを返すときに呼び出し元がAの先祖メソッドだと壊れそうなので禁止

関数（全ての関数はメンバ関数）から直接（修飾なしで）アクセス出来るのはそれをメンバとする構造体と、
その子孫構造体のメンバ変数とメンバ関数。（スコープ）

プリミティブな構造体はBool,SystemInt,SystemFloat,SystemString←これいる？

Integer、String、Floatなどの基本的な型は存在することを前提として、（けど、実装は組み込まないでユーザーレベルでやる（やりたいけど遅くなりそうだしどうしよ））
リテラルはSystem~型として解釈、変換はIntegerのメンバ関数としてインタプリタに組み込む。
SystemIntはループカウンタ、配列へのアクセスでも使う。

構造体周りの処理
・構造体ツリーの作成
・構造体指定が具体的にどの構造体を指しているのかを判断して構造体のポインタに置き換え
はAST作るときに一緒にやっちゃう。上述した閉路検出もこの時。

演算子はASTでは全部関数呼び出しと同一視する。

godStruct.main()を最初に呼び出す
main終わりでsolveして、SATだったらgodStruct.SATをよぶ、そうでないならgodStruct.UNSAT

プリミティブな命令
・代入
    variable = expression
・関数呼び出し（演算子含む）
    function()
・制約追加
    const(a,b,^c,^d,e...) const(BoolArray) 関数名あやしい、初見だと定数にしか見えない

operator+とかで演算子定義、左右の項のメンバ関数とスコープ内から定義を探す。演算子の優先順位はなんかそれっぽい感じで

サンプル　最大マッチングを求める。
struct Graph<SystemInt N>{ //単純無向グラフ　自己閉路なし
    Bool matrix[N][N];
    
    Graph(){
        Loop(i,N){
            matrix[i][i] = 0;
        }
    }

    void addEdge(SystemInt from, SystemInt to){
        const(matrix[from][to]);
        const(matrix[to][from]);
    }

    Integer<32> countEdge(){
        Integer<32> num(0);
        Loop(i,N){
            Loop(j,i){
                num = num + matrix[i][j];
            }
        }
        return num;
    }

    Graph getMatching(){
        Graph<N> ret;
        
        Loop(i,N){
            Loop(j,N){
                const(^ret.matrix[i][j],matrix[i][j]); //マッチングで辺があるのに元のグラフで辺がないのはおかしい。
                Loop(k,N){
                    const(^ret.matrix[i][j], ^ret.matrix[i][k]); //同じ頂点からは1本だけ
                }
            }
        }
        return ret;
    }
    Bool[N] getVertexCover(){
        //iroiro
    }
}

void main(){
    Graph<10> g, m;
    Integer<32> opt;

    const(g.countEdge() == Integer(20));
    m = g.getMatching();
    const(m.countEdge() == opt);
    const(sum(g.getVertexCover()) == opt);
}

void SAT(){
    print("SAT");
    print(opt);
    m.print();
}
void UNSAT(){
    print("UNSAT");
}

これC++へのトランスパイラでいいだろ
構造体のツリー構造とかはこっちのほうがすきなので俺のかち！

わざわざインタプリタを作るメリット・・・
・コンパイル時間がながいとか